<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>회전체 만들기</title>
  <link rel="icon" href="data:," />

  <script src="https://cdn.tailwindcss.com"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

  <style>
    @keyframes spinSlow { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    .animate-spin-slow { animation: spinSlow 2.5s linear infinite; }
    input[type="color"] { -webkit-appearance: none; border: none; padding: 0; background: transparent; }
    input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
    input[type="color"]::-webkit-color-swatch { border: 1px solid rgba(148,163,184,.6); border-radius: 10px; }
  </style>
</head>
<body class="bg-slate-50">
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useRef, useEffect, useMemo } = React;

    /* =========================
      Lucide 대체: 최소 SVG 아이콘
    ========================== */
    function IconBase({ children, size = 16, className = "" }) {
      return (
        <svg
          width={size}
          height={size}
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className={className}
          aria-hidden="true"
        >
          {children}
        </svg>
      );
    }
    const Trash2 = ({ size = 16, className = "" }) => (
      <IconBase size={size} className={className}>
        <path d="M3 6h18" />
        <path d="M8 6V4h8v2" />
        <path d="M6 6l1 16h10l1-16" />
        <path d="M10 11v6" />
        <path d="M14 11v6" />
      </IconBase>
    );
    const Undo = ({ size = 16, className = "" }) => (
      <IconBase size={size} className={className}>
        <path d="M9 14l-4-4 4-4" />
        <path d="M5 10h9a5 5 0 1 1 0 10h-3" />
      </IconBase>
    );
    const Box = ({ size = 24, className = "" }) => (
      <IconBase size={size} className={className}>
        <path d="M21 16V8a2 2 0 0 0-1-1.73L13 2.27a2 2 0 0 0-2 0L4 6.27A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z" />
        <path d="M3.3 7.5L12 12l8.7-4.5" />
        <path d="M12 22V12" />
      </IconBase>
    );
    const MousePointer2 = ({ size = 32, className = "" }) => (
      <IconBase size={size} className={className}>
        <path d="M4 3l7 18 2.5-7.5L21 11 4 3z" />
      </IconBase>
    );
    const Wand2 = ({ size = 12, className = "" }) => (
      <IconBase size={size} className={className}>
        <path d="M15 4l5 5" />
        <path d="M4 15l5 5" />
        <path d="M6 13l8-8" />
        <path d="M3 21l3-3" />
        <path d="M21 3l-3 3" />
      </IconBase>
    );
    const Magnet = ({ size = 12, className = "" }) => (
      <IconBase size={size} className={className}>
        <path d="M6 3v7a6 6 0 0 0 12 0V3" />
        <path d="M6 7h4" />
        <path d="M14 7h4" />
      </IconBase>
    );

    /* =========================
      색상 프리셋 (기본값: 적당한 색)
    ========================== */
    const DEFAULT_MODEL_COLOR = "#3b82f6"; // blue-500
    const DEFAULT_BG_COLOR = "#0f172a";    // slate-900

    /* =========================
      App (원본 로직 유지 + 색상 UI만 추가)
    ========================== */
    function App() {
      // --- 상수 ---
      const CANVAS_SIZE = 400;
      const CENTER_X = CANVAS_SIZE / 2;
      const SNAP_THRESHOLD = 10;
      const STRAIGHT_TOLERANCE = 6;

      // --- 상태 관리 ---
      const [points, setPoints] = useState([]);
      const [strokeHistory, setStrokeHistory] = useState([]);
      const [show3D, setShow3D] = useState(false);
      const [isAutoSnap, setIsAutoSnap] = useState(true);
      const [isStraight, setIsStraight] = useState(true);

      // ★ 추가: 3D 색상 상태
      const [modelColor, setModelColor] = useState(DEFAULT_MODEL_COLOR);
      const [bgColor, setBgColor] = useState(DEFAULT_BG_COLOR);

      const pointsRef = useRef([]);
      const isDrawing = useRef(false);
      const currentStrokeCount = useRef(0);
      const lastPoint = useRef(null);
      const isAutoSnapRef = useRef(true);
      const isStraightRef = useRef(true);

      const toggleStraight = () => {
        setIsStraight(prev => {
          const next = !prev;
          isStraightRef.current = next;
          return next;
        });
      };
      const toggleAutoSnap = () => {
        setIsAutoSnap(prev => {
          const next = !prev;
          isAutoSnapRef.current = next;
          return next;
        });
      };

      useEffect(() => { pointsRef.current = points; }, [points]);

      const strokes = useMemo(() => {
        const result = [];
        let currentIndex = 0;
        for (let count of strokeHistory) {
          result.push(points.slice(currentIndex, currentIndex + count));
          currentIndex += count;
        }
        if (currentIndex < points.length) result.push(points.slice(currentIndex));
        return result;
      }, [points, strokeHistory]);

      const getSnappedCoordinate = (x, y, currentPoints, isStart = false) => {
        let snappedX = x;
        let snappedY = y;
        let isSnapped = false;

        if (Math.abs(snappedX - CENTER_X) <= SNAP_THRESHOLD) {
          snappedX = CENTER_X;
          isSnapped = true;
        }

        if (currentPoints.length > 0) {
          const firstP = currentPoints[0];
          const distToFirst = Math.hypot(snappedX - firstP.x, snappedY - firstP.y);
          if (distToFirst <= SNAP_THRESHOLD) {
            return { x: firstP.x, y: firstP.y, isSnapped: true };
          }

          if (isStart) {
            const lastP = currentPoints[currentPoints.length - 1];
            const distToLast = Math.hypot(snappedX - lastP.x, snappedY - lastP.y);
            if (distToLast <= SNAP_THRESHOLD) {
              return { x: lastP.x, y: lastP.y, isSnapped: true };
            }
          }
        }

        return { x: snappedX, y: snappedY, isSnapped };
      };

      const straightenStroke = (strokePoints) => {
        if (strokePoints.length < 3) return strokePoints;

        const start = strokePoints[0];
        const end = strokePoints[strokePoints.length - 1];

        const A = start.y - end.y;
        const B = end.x - start.x;
        const C = start.x * end.y - end.x * start.y;
        const len = Math.hypot(A, B);
        if (len === 0) return strokePoints;

        let maxDev = 0;
        for (let p of strokePoints) {
          const dist = Math.abs(A * p.x + B * p.y + C) / len;
          if (dist > maxDev) maxDev = dist;
        }

        if (maxDev < STRAIGHT_TOLERANCE) return [start, end];
        return strokePoints;
      };

      const getCoordinates = (e) => {
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        const rect = e.target.getBoundingClientRect();
        return { x: clientX - rect.left, y: clientY - rect.top };
      };

      const startDrawing = (e) => {
        let { x, y } = getCoordinates(e);
        x = Math.min(x, CENTER_X);

        let initialPoints = [];
        if (isAutoSnapRef.current && pointsRef.current.length > 0) {
          const lastP = pointsRef.current[pointsRef.current.length - 1];
          initialPoints.push({ x: lastP.x, y: lastP.y });
        }

        if (isAutoSnapRef.current) {
          const snapped = getSnappedCoordinate(x, y, pointsRef.current, true);
          x = snapped.x; y = snapped.y;
        }

        isDrawing.current = true;
        setShow3D(false);

        const newPoint = { x, y };
        if (
          initialPoints.length === 0 ||
          initialPoints[0].x !== newPoint.x ||
          initialPoints[0].y !== newPoint.y
        ) {
          initialPoints.push(newPoint);
        }

        pointsRef.current = [...pointsRef.current, ...initialPoints];
        setPoints(pointsRef.current);

        currentStrokeCount.current = initialPoints.length;
        lastPoint.current = newPoint;
      };

      const draw = (e) => {
        if (!isDrawing.current) return;
        let { x, y } = getCoordinates(e);
        x = Math.min(x, CENTER_X);

        if (lastPoint.current) {
          const dist = Math.hypot(x - lastPoint.current.x, y - lastPoint.current.y);
          if (dist < 5) return;
        }

        const newPoint = { x, y };
        pointsRef.current = [...pointsRef.current, newPoint];
        setPoints(pointsRef.current);

        currentStrokeCount.current += 1;
        lastPoint.current = newPoint;
      };

      const stopDrawing = () => {
        if (!isDrawing.current) return;
        isDrawing.current = false;
        lastPoint.current = null;

        const count = currentStrokeCount.current;
        if (count > 0) {
          const currentTotalPoints = [...pointsRef.current];
          const startIndex = currentTotalPoints.length - count;

          let strokePoints = currentTotalPoints.slice(startIndex);

          if (isAutoSnapRef.current) {
            const lastP = strokePoints[strokePoints.length - 1];
            const snappedEnd = getSnappedCoordinate(
              lastP.x, lastP.y, currentTotalPoints.slice(0, startIndex), false
            );
            strokePoints[strokePoints.length - 1] = { x: snappedEnd.x, y: snappedEnd.y };
          }

          let finalPoints = strokePoints;
          if (isStraightRef.current) finalPoints = straightenStroke(strokePoints);

          const newTotalPoints = [
            ...currentTotalPoints.slice(0, startIndex),
            ...finalPoints
          ];

          pointsRef.current = newTotalPoints;
          setPoints(newTotalPoints);
          setStrokeHistory(prev => [...prev, finalPoints.length]);
        }

        currentStrokeCount.current = 0;
      };

      const drawRect = () => {
        const newPoints = [
          { x: 200, y: 100 },
          { x: 100, y: 100 },
          { x: 100, y: 300 },
          { x: 200, y: 300 },
        ];
        setPoints(newPoints);
        setStrokeHistory([4]);
        setShow3D(false);
      };

      const drawTriangle = () => {
        const newPoints = [
          { x: 200, y: 100 },
          { x: 50, y: 300 },
          { x: 200, y: 300 },
        ];
        setPoints(newPoints);
        setStrokeHistory([3]);
        setShow3D(false);
      };

      const drawSemicircle = () => {
        const center = { x: 200, y: 200 };
        const radius = 100;
        const newPoints = [];
        const steps = 30;
        for (let i = 0; i <= steps; i++) {
          const angle = -Math.PI / 2 + (Math.PI * i) / steps;
          newPoints.push({
            x: center.x - Math.cos(angle) * radius,
            y: center.y + Math.sin(angle) * radius
          });
        }
        setPoints(newPoints);
        setStrokeHistory([newPoints.length]);
        setShow3D(false);
      };

      const handleReset = () => {
        setPoints([]);
        setStrokeHistory([]);
        setShow3D(false);
      };

      const handleUndo = () => {
        if (strokeHistory.length === 0) return;
        const lastCount = strokeHistory[strokeHistory.length - 1];
        setPoints(prev => prev.slice(0, -lastCount));
        setStrokeHistory(prev => prev.slice(0, -1));
        setShow3D(false);
      };

      const handleGenerate3D = () => {
        if (points.length < 2) {
          alert("최소 2개 이상의 점이 필요합니다.");
          return;
        }
        setShow3D(true);
      };

      // ★ 추가: 간단 프리셋 버튼
      const presets = [
        { name: "파랑/슬레이트", model: "#3b82f6", bg: "#0f172a" },
        { name: "민트/딥그린", model: "#14b8a6", bg: "#052e2b" },
        { name: "오렌지/네이비", model: "#f97316", bg: "#0b1020" },
        { name: "퍼플/차콜", model: "#a855f7", bg: "#111827" },
      ];

      return (
        <div className="flex flex-col items-center w-full min-h-screen bg-slate-50 p-4 font-sans text-slate-800">
          <header className="mb-6 text-center">
            <h1 className="text-3xl font-bold text-blue-600 mb-2">회전체 만들기</h1>
            <p className="text-sm text-slate-500">
              선을 그으면 자동으로 직선이 보정되고 점들이 연결됩니다.
            </p>
          </header>

          <div className="flex flex-col lg:flex-row gap-8 items-start justify-center w-full max-w-6xl">

            {/* --- 2D 드로잉 영역 --- */}
            <div className="flex flex-col items-center w-full max-w-[400px]">
              <div className="w-full flex justify-between items-center mb-2">
                <div className="font-semibold text-lg flex items-center gap-2">
                  <span>1단계: 단면 그리기</span>
                </div>
                <div className="flex gap-2">
                  <button
                    onClick={toggleStraight}
                    className={`flex items-center gap-1 px-2 py-1 rounded text-xs font-medium transition-colors ${isStraight ? 'bg-blue-100 text-blue-700 hover:bg-blue-200' : 'bg-slate-200 text-slate-500 hover:bg-slate-300'}`}
                  >
                    <Wand2 size={12}/> 직선 보정 {isStraight ? 'ON' : 'OFF'}
                  </button>
                  <button
                    onClick={toggleAutoSnap}
                    className={`flex items-center gap-1 px-2 py-1 rounded text-xs font-medium transition-colors ${isAutoSnap ? 'bg-blue-100 text-blue-700 hover:bg-blue-200' : 'bg-slate-200 text-slate-500 hover:bg-slate-300'}`}
                  >
                    <Magnet size={12}/> 자동 스냅 {isAutoSnap ? 'ON' : 'OFF'}
                  </button>
                </div>
              </div>

              <div className="w-full grid grid-cols-3 gap-2 mb-3">
                <button onClick={drawRect} className="group flex flex-col items-center justify-center p-2 bg-white border border-slate-200 rounded hover:bg-blue-50 transition text-xs">
                  <div className="w-6 h-6 border-2 border-blue-500 mb-1 bg-blue-100 group-hover:bg-blue-200"></div>
                  원기둥
                </button>
                <button onClick={drawTriangle} className="group flex flex-col items-center justify-center p-2 bg-white border border-slate-200 rounded hover:bg-blue-50 transition text-xs">
                  <div className="w-0 h-0 border-l-[10px] border-l-transparent border-r-[10px] border-r-transparent border-b-[24px] border-b-blue-500 mb-1"></div>
                  원뿔
                </button>
                <button onClick={drawSemicircle} className="group flex flex-col items-center justify-center p-2 bg-white border border-slate-200 rounded hover:bg-blue-50 transition text-xs">
                  <div className="w-6 h-6 bg-blue-500 rounded-full mb-1 group-hover:scale-110 transition-transform"></div>
                  구
                </button>
              </div>

              <div
                className="relative bg-white shadow-lg border-2 border-slate-200 rounded-lg overflow-hidden touch-none cursor-crosshair"
                style={{ width: CANVAS_SIZE, height: CANVAS_SIZE }}
                onMouseDown={startDrawing}
                onMouseMove={draw}
                onMouseUp={stopDrawing}
                onMouseLeave={stopDrawing}
                onTouchStart={startDrawing}
                onTouchMove={draw}
                onTouchEnd={stopDrawing}
              >
                <GridBackground size={CANVAS_SIZE} />

                <div
                  className="absolute top-0 bottom-0 border-r-4 border-red-400 border-dashed z-10 pointer-events-none"
                  style={{ left: CENTER_X - 2 }}
                ></div>
                <div className="absolute top-2 left-1/2 ml-2 text-xs text-red-500 font-bold pointer-events-none bg-white/80 px-1 rounded">
                  회전축
                </div>

                <svg className="absolute top-0 left-0 w-full h-full pointer-events-none z-20">
                  {strokes.map((stroke, index) => (
                    <polyline
                      key={index}
                      points={stroke.map(p => `${p.x},${p.y}`).join(' ')}
                      fill="none"
                      stroke="#3b82f6"
                      strokeWidth="3"
                      strokeLinecap="round"
                      strokeLinejoin="round"
                    />
                  ))}
                  {points.map((p, i) => (
                    <circle key={`p-${i}`} cx={p.x} cy={p.y} r={2} fill="#2563eb" />
                  ))}
                </svg>

                {points.length === 0 && (
                  <div className="absolute inset-0 flex flex-col items-center justify-center pointer-events-none opacity-40 gap-2">
                    <MousePointer2 size={32} className="text-slate-400 animate-bounce" />
                    <span className="text-slate-400">마우스로 드래그하여 그리세요</span>
                  </div>
                )}
              </div>

              <div className="flex gap-2 mt-4 w-full">
                <button
                  onClick={handleUndo}
                  disabled={points.length === 0}
                  className="flex-1 flex justify-center items-center gap-1 px-4 py-2 bg-gray-200 hover:bg-gray-300 rounded-lg disabled:opacity-50 transition text-sm font-medium"
                >
                  <Undo size={16} /> 실행 취소 (한 획)
                </button>
                <button
                  onClick={handleReset}
                  disabled={points.length === 0}
                  className="flex-1 flex justify-center items-center gap-1 px-4 py-2 bg-red-100 text-red-600 hover:bg-red-200 rounded-lg disabled:opacity-50 transition text-sm font-medium"
                >
                  <Trash2 size={16} /> 모두 지우기
                </button>
              </div>
            </div>

            <div className="hidden lg:flex flex-col items-center justify-center h-[400px]">
              <button
                onClick={handleGenerate3D}
                className="group flex flex-col items-center gap-2 px-6 py-4 bg-blue-600 hover:bg-blue-700 text-white rounded-xl shadow-lg transition-all transform hover:scale-105 active:scale-95"
              >
                <Box size={32} className="animate-spin-slow" />
                <span className="font-bold text-lg">회전체 만들기</span>
                <span className="text-xs opacity-80">Click!</span>
              </button>
            </div>

            <div className="lg:hidden w-full flex justify-center my-4">
              <button
                onClick={handleGenerate3D}
                className="flex items-center gap-2 px-8 py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-xl shadow-lg w-full max-w-[400px] justify-center"
              >
                <Box size={24} />
                <span className="font-bold">회전체 만들기</span>
              </button>
            </div>

            {/* --- 3D 뷰어 영역 --- */}
            <div className="flex flex-col items-center w-full lg:w-auto">
              <div className="mb-2 font-semibold text-lg flex items-center gap-2">
                <span>2단계: 결과 확인</span>
              </div>

              {/* ★ 추가: 색상 컨트롤 패널 */}
              <div className="w-full max-w-[400px] lg:max-w-none mb-3">
                <div className="bg-white border border-slate-200 rounded-xl shadow-sm px-3 py-2 flex flex-col gap-2">
                  <div className="flex items-center justify-between gap-2">
                    <div className="text-xs font-semibold text-slate-600">3D 색상 설정</div>
                    <div className="flex gap-2">
                      {presets.map((p) => (
                        <button
                          key={p.name}
                          onClick={() => { setModelColor(p.model); setBgColor(p.bg); }}
                          className="text-[11px] px-2 py-1 rounded-lg border border-slate-200 hover:bg-slate-50"
                          title={p.name}
                        >
                          {p.name}
                        </button>
                      ))}
                    </div>
                  </div>

                  <div className="flex items-center justify-between gap-3">
                    <label className="flex items-center gap-2 text-xs text-slate-600">
                      회전체 색
                      <input
                        type="color"
                        value={modelColor}
                        onChange={(e) => setModelColor(e.target.value)}
                        className="w-10 h-8 rounded-lg"
                        aria-label="회전체 색 선택"
                      />
                      <span className="font-mono text-[11px] text-slate-500">{modelColor}</span>
                    </label>

                    <label className="flex items-center gap-2 text-xs text-slate-600">
                      배경색
                      <input
                        type="color"
                        value={bgColor}
                        onChange={(e) => setBgColor(e.target.value)}
                        className="w-10 h-8 rounded-lg"
                        aria-label="배경색 선택"
                      />
                      <span className="font-mono text-[11px] text-slate-500">{bgColor}</span>
                    </label>

                    <button
                      onClick={() => { setModelColor(DEFAULT_MODEL_COLOR); setBgColor(DEFAULT_BG_COLOR); }}
                      className="text-xs px-3 py-2 rounded-lg bg-slate-100 hover:bg-slate-200"
                    >
                      기본값
                    </button>
                  </div>

                  <div className="text-[11px] text-slate-500">
                    ※ 색을 바꾸면 3D 화면에 바로 반영돼요.
                  </div>
                </div>
              </div>

              <div
                className="relative bg-slate-900 rounded-lg shadow-lg overflow-hidden border-2 border-slate-700"
                style={{ width: CANVAS_SIZE, height: CANVAS_SIZE }}
              >
                {show3D ? (
                  <ThreeScene
                    strokes={strokes}
                    canvasSize={CANVAS_SIZE}
                    centerX={CENTER_X}
                    modelColor={modelColor}
                    bgColor={bgColor}
                  />
                ) : (
                  <div className="w-full h-full flex flex-col items-center justify-center text-slate-500">
                    <Box size={48} className="mb-2 opacity-20" />
                    <p>도형을 만들고 버튼을 누르세요</p>
                  </div>
                )}
              </div>

              {show3D && (
                <div className="mt-4 text-sm text-slate-600 bg-white px-4 py-2 rounded-full border border-slate-200 shadow-sm animate-pulse">
                  ✨ 마우스 드래그로 회전, 마우스 휠(스크롤)로 줌인/줌아웃 해보세요!
                </div>
              )}
            </div>

          </div>
        </div>
      );
    }

    function GridBackground({ size }) {
      const step = 40;
      const lines = [];
      for (let i = step; i < size; i += step) lines.push(i);

      return (
        <svg className="absolute inset-0 w-full h-full pointer-events-none opacity-20">
          {lines.map((pos) => (
            <React.Fragment key={pos}>
              <line x1={pos} y1={0} x2={pos} y2={size} stroke="#94a3b8" strokeWidth="1" />
              <line x1={0} y1={pos} x2={size} y2={pos} stroke="#94a3b8" strokeWidth="1" />
            </React.Fragment>
          ))}
        </svg>
      );
    }

    function ThreeScene({ strokes, canvasSize, centerX, modelColor, bgColor }) {
      const mountRef = useRef(null);
      const sceneRef = useRef(null);
      const groupRef = useRef(null);
      const animationProgress = useRef(0);

      useEffect(() => {
        if (!mountRef.current) return;

        const scene = new THREE.Scene();
        // ★ 배경색 반영
        scene.background = new THREE.Color(bgColor);
        sceneRef.current = scene;

        const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 1000);
        camera.position.set(0, 100, 400);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(canvasSize, canvasSize);
        mountRef.current.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(20, 50, 20);
        scene.add(dirLight);
        const backLight = new THREE.DirectionalLight(0x4444ff, 0.5);
        backLight.position.set(-20, -20, -20);
        scene.add(backLight);

        const createLathe = (maxAngle) => {
          if (groupRef.current) {
            groupRef.current.children.forEach(child => {
              if (child.geometry) child.geometry.dispose();
              if (child.material) {
                if (Array.isArray(child.material)) child.material.forEach(m => m.dispose());
                else child.material.dispose();
              }
            });
            scene.remove(groupRef.current);
          }

          const group = new THREE.Group();

          strokes.forEach(stroke => {
            if (stroke.length < 2) return;

            const threePoints = stroke.map(p => {
              const radius = Math.abs(centerX - p.x);
              const height = -(p.y - canvasSize / 2);
              return new THREE.Vector2(radius, height);
            });

            const geometry = new THREE.LatheGeometry(threePoints, 32, 0, maxAngle);

            // ★ 회전체 색 반영
            const material = new THREE.MeshPhongMaterial({
              color: new THREE.Color(modelColor),
              side: THREE.DoubleSide,
              flatShading: false,
              shininess: 80,
              specular: 0x222222
            });

            const mesh = new THREE.Mesh(geometry, material);
            group.add(mesh);

            const wfGeo = new THREE.WireframeGeometry(geometry);
            const wfMat = new THREE.LineBasicMaterial({
              color: new THREE.Color(modelColor),
              transparent: true,
              opacity: 0.18
            });
            const wireframe = new THREE.LineSegments(wfGeo, wfMat);
            group.add(wireframe);
          });

          scene.add(group);
          groupRef.current = group;
        };

        let reqId;
        animationProgress.current = 0;

        const animate = () => {
          reqId = requestAnimationFrame(animate);

          if (animationProgress.current < Math.PI * 2) {
            animationProgress.current += 0.08;
            if (animationProgress.current > Math.PI * 2) {
              animationProgress.current = Math.PI * 2;
            }
            createLathe(animationProgress.current);
          }

          renderer.render(scene, camera);
        };

        animate();

        let isDragging = false;
        let prevMouse = { x: 0, y: 0 };
        let initialPinchDistance = null;
        let initialCameraZ = null;

        const onMouseDown = (e) => {
          isDragging = true;
          prevMouse = { x: e.clientX, y: e.clientY };
        };
        const onMouseUp = () => { isDragging = false; };
        const onMouseMove = (e) => {
          if (!isDragging) return;
          const deltaX = e.clientX - prevMouse.x;
          const deltaY = e.clientY - prevMouse.y;
          prevMouse = { x: e.clientX, y: e.clientY };

          if (groupRef.current) {
            groupRef.current.rotation.y += deltaX * 0.01;
            groupRef.current.rotation.x += deltaY * 0.01;
          }
        };

        const onWheel = (e) => {
          e.preventDefault();
          const zoomSpeed = 0.5;
          camera.position.z += e.deltaY * zoomSpeed;
          camera.position.z = Math.max(100, Math.min(1000, camera.position.z));
        };

        const onTouchStart = (e) => {
          e.preventDefault();
          if (e.touches.length === 1) {
            isDragging = true;
            prevMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
          } else if (e.touches.length === 2) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            initialPinchDistance = Math.hypot(dx, dy);
            initialCameraZ = camera.position.z;
          }
        };

        const onTouchMove = (e) => {
          e.preventDefault();
          if (e.touches.length === 1 && isDragging) {
            const deltaX = e.touches[0].clientX - prevMouse.x;
            const deltaY = e.touches[0].clientY - prevMouse.y;
            prevMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };

            if (groupRef.current) {
              groupRef.current.rotation.y += deltaX * 0.01;
              groupRef.current.rotation.x += deltaY * 0.01;
            }
          } else if (e.touches.length === 2 && initialPinchDistance !== null) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            const dist = Math.hypot(dx, dy);
            const scale = initialPinchDistance / dist;
            camera.position.z = Math.max(100, Math.min(1000, initialCameraZ * scale));
          }
        };

        const onTouchEnd = (e) => {
          if (e.touches.length < 2) initialPinchDistance = null;
          if (e.touches.length === 0) isDragging = false;
        };

        const canvas = renderer.domElement;
        canvas.addEventListener('mousedown', onMouseDown);
        window.addEventListener('mouseup', onMouseUp);
        window.addEventListener('mousemove', onMouseMove);
        canvas.addEventListener('wheel', onWheel, { passive: false });
        canvas.addEventListener('touchstart', onTouchStart, { passive: false });
        canvas.addEventListener('touchmove', onTouchMove, { passive: false });
        canvas.addEventListener('touchend', onTouchEnd);

        return () => {
          cancelAnimationFrame(reqId);
          canvas.removeEventListener('mousedown', onMouseDown);
          window.removeEventListener('mouseup', onMouseUp);
          window.removeEventListener('mousemove', onMouseMove);
          canvas.removeEventListener('wheel', onWheel);
          canvas.removeEventListener('touchstart', onTouchStart);
          canvas.removeEventListener('touchmove', onTouchMove);
          canvas.removeEventListener('touchend', onTouchEnd);
          if (mountRef.current) mountRef.current.removeChild(renderer.domElement);
        };
      }, [strokes, canvasSize, centerX, modelColor, bgColor]); // ★ 색 바뀌면 재렌더

      return <div ref={mountRef} className="w-full h-full cursor-move touch-none" />;
    }

    const root = ReactDOM.createRoot(document.getElementById("root"));
    root.render(<App />);
  </script>
</body>
</html>
