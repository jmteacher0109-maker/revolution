<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>회전체 만들기</title>
  <link rel="icon" href="data:," />

  <!-- Tailwind CDN -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- React 18 + ReactDOM CDN -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

  <!-- Babel (JSX in browser) -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- Three.js CDN -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

  <style>
    /* Tailwind 커스텀 클래스 대체 */
    @keyframes spinSlow { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    .animate-spin-slow { animation: spinSlow 2.5s linear infinite; }
  </style>
</head>
<body class="bg-slate-50">
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useRef, useEffect, useMemo } = React;

    /* =========================
      Lucide 대체: 최소 SVG 아이콘
      (이 부분만 import 대체용)
    ========================== */
    function IconBase({ children, size = 16, className = "" }) {
      return (
        <svg
          width={size}
          height={size}
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className={className}
          aria-hidden="true"
        >
          {children}
        </svg>
      );
    }

    const Trash2 = ({ size = 16, className = "" }) => (
      <IconBase size={size} className={className}>
        <path d="M3 6h18" />
        <path d="M8 6V4h8v2" />
        <path d="M6 6l1 16h10l1-16" />
        <path d="M10 11v6" />
        <path d="M14 11v6" />
      </IconBase>
    );

    const Undo = ({ size = 16, className = "" }) => (
      <IconBase size={size} className={className}>
        <path d="M9 14l-4-4 4-4" />
        <path d="M5 10h9a5 5 0 1 1 0 10h-3" />
      </IconBase>
    );

    const Box = ({ size = 24, className = "" }) => (
      <IconBase size={size} className={className}>
        <path d="M21 16V8a2 2 0 0 0-1-1.73L13 2.27a2 2 0 0 0-2 0L4 6.27A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z" />
        <path d="M3.3 7.5L12 12l8.7-4.5" />
        <path d="M12 22V12" />
      </IconBase>
    );

    const MousePointer2 = ({ size = 32, className = "" }) => (
      <IconBase size={size} className={className}>
        <path d="M4 3l7 18 2.5-7.5L21 11 4 3z" />
      </IconBase>
    );

    const Wand2 = ({ size = 12, className = "" }) => (
      <IconBase size={size} className={className}>
        <path d="M15 4l5 5" />
        <path d="M4 15l5 5" />
        <path d="M6 13l8-8" />
        <path d="M3 21l3-3" />
        <path d="M21 3l-3 3" />
      </IconBase>
    );

    const Magnet = ({ size = 12, className = "" }) => (
      <IconBase size={size} className={className}>
        <path d="M6 3v7a6 6 0 0 0 12 0V3" />
        <path d="M6 7h4" />
        <path d="M14 7h4" />
      </IconBase>
    );

    /* =========================
      App (원본 로직 유지)
    ========================== */
    function App() {
      // --- 상수 ---
      const CANVAS_SIZE = 400;
      const CENTER_X = CANVAS_SIZE / 2; // 회전축 (x=200)
      const SNAP_THRESHOLD = 10; // 스냅 거리 (px)
      const STRAIGHT_TOLERANCE = 6; // 직선 보정 허용 오차 (px)

      // --- 상태 관리 ---
      const [points, setPoints] = useState([]); // 전체 좌표 점들
      const [strokeHistory, setStrokeHistory] = useState([]); // 각 획(Stroke) 정보 기록
      const [show3D, setShow3D] = useState(false); // 3D 뷰 활성화 여부
      const [isAutoSnap, setIsAutoSnap] = useState(true); // 자동 스냅 켜기/끄기
      const [isStraight, setIsStraight] = useState(true); // 직선 보정 켜기/끄기

      // Ref를 사용하여 이벤트 핸들러 내에서 최신 상태 조회
      const pointsRef = useRef([]);
      const isDrawing = useRef(false);
      const currentStrokeCount = useRef(0);
      const lastPoint = useRef(null);
      const isAutoSnapRef = useRef(true);
      const isStraightRef = useRef(true);

      const toggleStraight = () => {
        setIsStraight(prev => {
          const next = !prev;
          isStraightRef.current = next;
          return next;
        });
      };

      const toggleAutoSnap = () => {
        setIsAutoSnap(prev => {
          const next = !prev;
          isAutoSnapRef.current = next;
          return next;
        });
      };

      // 상태 동기화
      useEffect(() => {
        pointsRef.current = points;
      }, [points]);

      // ★ 다중 획(떨어진 선들)을 분리해주는 로직
      const strokes = useMemo(() => {
        const result = [];
        let currentIndex = 0;
        for (let count of strokeHistory) {
          result.push(points.slice(currentIndex, currentIndex + count));
          currentIndex += count;
        }
        // 현재 그리고 있는(완료되지 않은) 획 추가
        if (currentIndex < points.length) {
          result.push(points.slice(currentIndex));
        }
        return result;
      }, [points, strokeHistory]);

      // --- 유틸리티: 스냅 계산 ---
      const getSnappedCoordinate = (x, y, currentPoints, isStart = false) => {
        let snappedX = x;
        let snappedY = y;
        let isSnapped = false;

        // 1. 회전축(Axis) 스냅
        if (Math.abs(snappedX - CENTER_X) <= SNAP_THRESHOLD) {
          snappedX = CENTER_X;
          isSnapped = true;
        }

        // 2. 기존 점 스냅
        if (currentPoints.length > 0) {
          // (1) 처음 시작점 스냅 (도형 닫기)
          const firstP = currentPoints[0];
          const distToFirst = Math.hypot(snappedX - firstP.x, snappedY - firstP.y);
          if (distToFirst <= SNAP_THRESHOLD) {
            return { x: firstP.x, y: firstP.y, isSnapped: true };
          }

          // (2) 직전 선의 끝점 스냅 (선 이어 그리기)
          if (isStart) {
            const lastP = currentPoints[currentPoints.length - 1];
            const distToLast = Math.hypot(snappedX - lastP.x, snappedY - lastP.y);
            if (distToLast <= SNAP_THRESHOLD) {
              return { x: lastP.x, y: lastP.y, isSnapped: true };
            }
          }
        }

        return { x: snappedX, y: snappedY, isSnapped };
      };

      // --- 유틸리티: 직선 보정 ---
      const straightenStroke = (strokePoints) => {
        if (strokePoints.length < 3) return strokePoints;

        const start = strokePoints[0];
        const end = strokePoints[strokePoints.length - 1];

        const A = start.y - end.y;
        const B = end.x - start.x;
        const C = start.x * end.y - end.x * start.y;
        const len = Math.hypot(A, B);

        if (len === 0) return strokePoints;

        let maxDev = 0;
        for (let p of strokePoints) {
          const dist = Math.abs(A * p.x + B * p.y + C) / len;
          if (dist > maxDev) maxDev = dist;
        }

        if (maxDev < STRAIGHT_TOLERANCE) {
          return [start, end];
        }

        return strokePoints;
      };

      // --- 핸들러: 2D 드로잉 ---
      const getCoordinates = (e) => {
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        const rect = e.target.getBoundingClientRect();
        return { x: clientX - rect.left, y: clientY - rect.top };
      };

      const startDrawing = (e) => {
        let { x, y } = getCoordinates(e);

        x = Math.min(x, CENTER_X);

        let initialPoints = [];

        // ★ 자동 스냅 켜짐: 띄워서 클릭해도 이전 점과 강제로 선을 연결합니다 ("아까처럼")
        if (isAutoSnapRef.current && pointsRef.current.length > 0) {
          const lastP = pointsRef.current[pointsRef.current.length - 1];
          initialPoints.push({ x: lastP.x, y: lastP.y });
        }

        // 스냅 적용 (토글이 켜져있을 때만)
        if (isAutoSnapRef.current) {
          const snapped = getSnappedCoordinate(x, y, pointsRef.current, true);
          x = snapped.x;
          y = snapped.y;
        }

        isDrawing.current = true;
        setShow3D(false);

        const newPoint = { x, y };

        // 이전 점과 완전히 같은 위치가 아닐 때만 현재 클릭한 점을 추가합니다.
        if (
          initialPoints.length === 0 ||
          initialPoints[0].x !== newPoint.x ||
          initialPoints[0].y !== newPoint.y
        ) {
          initialPoints.push(newPoint);
        }

        pointsRef.current = [...pointsRef.current, ...initialPoints];
        setPoints(pointsRef.current);

        currentStrokeCount.current = initialPoints.length;
        lastPoint.current = newPoint;
      };

      const draw = (e) => {
        if (!isDrawing.current) return;
        let { x, y } = getCoordinates(e);

        x = Math.min(x, CENTER_X);

        if (lastPoint.current) {
          const dist = Math.hypot(x - lastPoint.current.x, y - lastPoint.current.y);
          if (dist < 5) return;
        }

        const newPoint = { x, y };
        pointsRef.current = [...pointsRef.current, newPoint];
        setPoints(pointsRef.current);

        currentStrokeCount.current += 1;
        lastPoint.current = newPoint;
      };

      const stopDrawing = () => {
        if (!isDrawing.current) return;
        isDrawing.current = false;
        lastPoint.current = null;

        const count = currentStrokeCount.current;
        if (count > 0) {
          const currentTotalPoints = [...pointsRef.current];
          const startIndex = currentTotalPoints.length - count;

          let strokePoints = currentTotalPoints.slice(startIndex);

          if (isAutoSnapRef.current) {
            const lastP = strokePoints[strokePoints.length - 1];
            const snappedEnd = getSnappedCoordinate(
              lastP.x,
              lastP.y,
              currentTotalPoints.slice(0, startIndex),
              false
            );
            strokePoints[strokePoints.length - 1] = { x: snappedEnd.x, y: snappedEnd.y };
          }

          let finalPoints = strokePoints;
          if (isStraightRef.current) {
            finalPoints = straightenStroke(strokePoints);
          }

          const newTotalPoints = [
            ...currentTotalPoints.slice(0, startIndex),
            ...finalPoints
          ];

          pointsRef.current = newTotalPoints;
          setPoints(newTotalPoints);
          setStrokeHistory(prev => [...prev, finalPoints.length]);
        }

        currentStrokeCount.current = 0;
      };

      // --- 기본 도형 프리셋 ---
      const drawRect = () => {
        const newPoints = [
          { x: 200, y: 100 },
          { x: 100, y: 100 },
          { x: 100, y: 300 },
          { x: 200, y: 300 },
        ];
        setPoints(newPoints);
        setStrokeHistory([4]);
        setShow3D(false);
      };

      const drawTriangle = () => {
        const newPoints = [
          { x: 200, y: 100 },
          { x: 50, y: 300 },
          { x: 200, y: 300 },
        ];
        setPoints(newPoints);
        setStrokeHistory([3]);
        setShow3D(false);
      };

      const drawSemicircle = () => {
        const center = { x: 200, y: 200 };
        const radius = 100;
        const newPoints = [];
        const steps = 30;
        for (let i = 0; i <= steps; i++) {
          const angle = -Math.PI / 2 + (Math.PI * i) / steps;
          newPoints.push({
            x: center.x - Math.cos(angle) * radius,
            y: center.y + Math.sin(angle) * radius
          });
        }
        setPoints(newPoints);
        setStrokeHistory([newPoints.length]);
        setShow3D(false);
      };

      const handleReset = () => {
        setPoints([]);
        setStrokeHistory([]);
        setShow3D(false);
      };

      const handleUndo = () => {
        if (strokeHistory.length === 0) return;
        const lastCount = strokeHistory[strokeHistory.length - 1];
        setPoints(prev => prev.slice(0, -lastCount));
        setStrokeHistory(prev => prev.slice(0, -1));
        setShow3D(false);
      };

      const handleGenerate3D = () => {
        if (points.length < 2) {
          alert("최소 2개 이상의 점이 필요합니다.");
          return;
        }
        setShow3D(true);
      };

      return (
        <div className="flex flex-col items-center w-full min-h-screen bg-slate-50 p-4 font-sans text-slate-800">
          <header className="mb-6 text-center">
            <h1 className="text-3xl font-bold text-blue-600 mb-2">회전체 만들기</h1>
            <p className="text-sm text-slate-500">
              선을 그으면 자동으로 직선이 보정되고 점들이 연결됩니다.
            </p>
          </header>

          <div className="flex flex-col lg:flex-row gap-8 items-start justify-center w-full max-w-6xl">

            {/* --- 2D 드로잉 영역 --- */}
            <div className="flex flex-col items-center w-full max-w-[400px]">
              <div className="w-full flex justify-between items-center mb-2">
                <div className="font-semibold text-lg flex items-center gap-2">
                  <span>1단계: 단면 그리기</span>
                </div>
                <div className="flex gap-2">
                  <button
                    onClick={toggleStraight}
                    className={`flex items-center gap-1 px-2 py-1 rounded text-xs font-medium transition-colors ${isStraight ? 'bg-blue-100 text-blue-700 hover:bg-blue-200' : 'bg-slate-200 text-slate-500 hover:bg-slate-300'}`}
                  >
                    <Wand2 size={12}/> 직선 보정 {isStraight ? 'ON' : 'OFF'}
                  </button>
                  <button
                    onClick={toggleAutoSnap}
                    className={`flex items-center gap-1 px-2 py-1 rounded text-xs font-medium transition-colors ${isAutoSnap ? 'bg-blue-100 text-blue-700 hover:bg-blue-200' : 'bg-slate-200 text-slate-500 hover:bg-slate-300'}`}
                  >
                    <Magnet size={12}/> 자동 스냅 {isAutoSnap ? 'ON' : 'OFF'}
                  </button>
                </div>
              </div>

              <div className="w-full grid grid-cols-3 gap-2 mb-3">
                <button onClick={drawRect} className="group flex flex-col items-center justify-center p-2 bg-white border border-slate-200 rounded hover:bg-blue-50 transition text-xs">
                  <div className="w-6 h-6 border-2 border-blue-500 mb-1 bg-blue-100 group-hover:bg-blue-200"></div>
                  원기둥
                </button>
                <button onClick={drawTriangle} className="group flex flex-col items-center justify-center p-2 bg-white border border-slate-200 rounded hover:bg-blue-50 transition text-xs">
                  <div className="w-0 h-0 border-l-[10px] border-l-transparent border-r-[10px] border-r-transparent border-b-[24px] border-b-blue-500 mb-1"></div>
                  원뿔
                </button>
                <button onClick={drawSemicircle} className="group flex flex-col items-center justify-center p-2 bg-white border border-slate-200 rounded hover:bg-blue-50 transition text-xs">
                  <div className="w-6 h-6 bg-blue-500 rounded-full mb-1 group-hover:scale-110 transition-transform"></div>
                  구
                </button>
              </div>

              <div
                className="relative bg-white shadow-lg border-2 border-slate-200 rounded-lg overflow-hidden touch-none cursor-crosshair"
                style={{ width: CANVAS_SIZE, height: CANVAS_SIZE }}
                onMouseDown={startDrawing}
                onMouseMove={draw}
                onMouseUp={stopDrawing}
                onMouseLeave={stopDrawing}
                onTouchStart={startDrawing}
                onTouchMove={draw}
                onTouchEnd={stopDrawing}
              >
                <GridBackground size={CANVAS_SIZE} />

                <div
                  className="absolute top-0 bottom-0 border-r-4 border-red-400 border-dashed z-10 pointer-events-none"
                  style={{ left: CENTER_X - 2 }}
                ></div>
                <div className="absolute top-2 left-1/2 ml-2 text-xs text-red-500 font-bold pointer-events-none bg-white/80 px-1 rounded">
                  회전축
                </div>

                {/* ★ 변경된 부분: 획(strokes)마다 독립적인 선(polyline)을 그림 */}
                <svg className="absolute top-0 left-0 w-full h-full pointer-events-none z-20">
                  {strokes.map((stroke, index) => (
                    <polyline
                      key={index}
                      points={stroke.map(p => `${p.x},${p.y}`).join(' ')}
                      fill="none"
                      stroke="#3b82f6"
                      strokeWidth="3"
                      strokeLinecap="round"
                      strokeLinejoin="round"
                    />
                  ))}

                  {points.map((p, i) => (
                    <circle key={`p-${i}`} cx={p.x} cy={p.y} r={2} fill="#2563eb" />
                  ))}
                </svg>

                {points.length === 0 && (
                  <div className="absolute inset-0 flex flex-col items-center justify-center pointer-events-none opacity-40 gap-2">
                    <MousePointer2 size={32} className="text-slate-400 animate-bounce" />
                    <span className="text-slate-400">마우스로 드래그하여 그리세요</span>
                  </div>
                )}
              </div>

              <div className="flex gap-2 mt-4 w-full">
                <button
                  onClick={handleUndo}
                  disabled={points.length === 0}
                  className="flex-1 flex justify-center items-center gap-1 px-4 py-2 bg-gray-200 hover:bg-gray-300 rounded-lg disabled:opacity-50 transition text-sm font-medium"
                >
                  <Undo size={16} /> 실행 취소 (한 획)
                </button>
                <button
                  onClick={handleReset}
                  disabled={points.length === 0}
                  className="flex-1 flex justify-center items-center gap-1 px-4 py-2 bg-red-100 text-red-600 hover:bg-red-200 rounded-lg disabled:opacity-50 transition text-sm font-medium"
                >
                  <Trash2 size={16} /> 모두 지우기
                </button>
              </div>
            </div>

            <div className="hidden lg:flex flex-col items-center justify-center h-[400px]">
              <button
                onClick={handleGenerate3D}
                className="group flex flex-col items-center gap-2 px-6 py-4 bg-blue-600 hover:bg-blue-700 text-white rounded-xl shadow-lg transition-all transform hover:scale-105 active:scale-95"
              >
                <Box size={32} className="animate-spin-slow" />
                <span className="font-bold text-lg">회전체 만들기</span>
                <span className="text-xs opacity-80">Click!</span>
              </button>
            </div>

            <div className="lg:hidden w-full flex justify-center my-4">
              <button
                onClick={handleGenerate3D}
                className="flex items-center gap-2 px-8 py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-xl shadow-lg w-full max-w-[400px] justify-center"
              >
                <Box size={24} />
                <span className="font-bold">회전체 만들기</span>
              </button>
            </div>

            {/* --- 3D 뷰어 영역 --- */}
            <div className="flex flex-col items-center">
              <div className="mb-2 font-semibold text-lg flex items-center gap-2">
                <span>2단계: 결과 확인</span>
              </div>

              <div
                className="relative bg-slate-900 rounded-lg shadow-lg overflow-hidden border-2 border-slate-700"
                style={{ width: CANVAS_SIZE, height: CANVAS_SIZE }}
              >
                {show3D ? (
                  <ThreeScene strokes={strokes} canvasSize={CANVAS_SIZE} centerX={CENTER_X} />
                ) : (
                  <div className="w-full h-full flex flex-col items-center justify-center text-slate-500">
                    <Box size={48} className="mb-2 opacity-20" />
                    <p>도형을 만들고 버튼을 누르세요</p>
                  </div>
                )}
              </div>

              {show3D && (
                <div className="mt-4 text-sm text-slate-600 bg-white px-4 py-2 rounded-full border border-slate-200 shadow-sm animate-pulse">
                  ✨ 마우스 드래그로 회전, 마우스 휠(스크롤)로 줌인/줌아웃 해보세요!
                </div>
              )}
            </div>

          </div>
        </div>
      );
    }

    // --- 보조 컴포넌트: 그리드 배경 ---
    function GridBackground({ size }) {
      const step = 40;
      const lines = [];
      for (let i = step; i < size; i += step) lines.push(i);

      return (
        <svg className="absolute inset-0 w-full h-full pointer-events-none opacity-20">
          {lines.map((pos) => (
            <React.Fragment key={pos}>
              <line x1={pos} y1={0} x2={pos} y2={size} stroke="#94a3b8" strokeWidth="1" />
              <line x1={0} y1={pos} x2={size} y2={pos} stroke="#94a3b8" strokeWidth="1" />
            </React.Fragment>
          ))}
        </svg>
      );
    }

    // --- 핵심 컴포넌트: Three.js 씬 ---
    function ThreeScene({ strokes, canvasSize, centerX }) {
      const mountRef = useRef(null);
      const sceneRef = useRef(null);
      const groupRef = useRef(null); // 메쉬 그룹 관리
      const animationProgress = useRef(0);

      useEffect(() => {
        if (!mountRef.current) return;

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0f172a);
        sceneRef.current = scene;

        const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 1000);
        camera.position.set(0, 100, 400);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(canvasSize, canvasSize);
        mountRef.current.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(20, 50, 20);
        scene.add(dirLight);
        const backLight = new THREE.DirectionalLight(0x4444ff, 0.5);
        backLight.position.set(-20, -20, -20);
        scene.add(backLight);

        // ★ 변경된 부분: 분리된 획(strokes)마다 개별적으로 3D 객체(Mesh)를 생성하여 묶음(Group)
        const createLathe = (maxAngle) => {
          if (groupRef.current) {
            groupRef.current.children.forEach(child => {
              if (child.geometry) child.geometry.dispose();
              if (child.material) {
                if (Array.isArray(child.material)) child.material.forEach(m => m.dispose());
                else child.material.dispose();
              }
            });
            scene.remove(groupRef.current);
          }

          const group = new THREE.Group();

          strokes.forEach(stroke => {
            if (stroke.length < 2) return;

            const threePoints = stroke.map(p => {
              const radius = Math.abs(centerX - p.x);
              const height = -(p.y - canvasSize / 2);
              return new THREE.Vector2(radius, height);
            });

            const geometry = new THREE.LatheGeometry(threePoints, 32, 0, maxAngle);
            const material = new THREE.MeshPhongMaterial({
              color: 0x3b82f6,
              side: THREE.DoubleSide,
              flatShading: false,
              shininess: 80,
              specular: 0x222222
            });

            const mesh = new THREE.Mesh(geometry, material);
            group.add(mesh);

            const wfGeo = new THREE.WireframeGeometry(geometry);
            const wfMat = new THREE.LineBasicMaterial({ color: 0x93c5fd, transparent: true, opacity: 0.2 });
            const wireframe = new THREE.LineSegments(wfGeo, wfMat);
            group.add(wireframe);
          });

          scene.add(group);
          groupRef.current = group;
        };

        let reqId;
        animationProgress.current = 0;

        const animate = () => {
          reqId = requestAnimationFrame(animate);

          if (animationProgress.current < Math.PI * 2) {
            animationProgress.current += 0.08;
            if (animationProgress.current > Math.PI * 2) {
              animationProgress.current = Math.PI * 2;
            }
            createLathe(animationProgress.current);
          }

          renderer.render(scene, camera);
        };

        animate();

        let isDragging = false;
        let prevMouse = { x: 0, y: 0 };
        let initialPinchDistance = null;
        let initialCameraZ = null;

        const onMouseDown = (e) => {
          isDragging = true;
          prevMouse = { x: e.clientX, y: e.clientY };
        };
        const onMouseUp = () => { isDragging = false; };
        const onMouseMove = (e) => {
          if (!isDragging) return;
          const deltaX = e.clientX - prevMouse.x;
          const deltaY = e.clientY - prevMouse.y;
          prevMouse = { x: e.clientX, y: e.clientY };

          if (groupRef.current) {
            groupRef.current.rotation.y += deltaX * 0.01;
            groupRef.current.rotation.x += deltaY * 0.01;
          }
        };

        const onWheel = (e) => {
          e.preventDefault();
          const zoomSpeed = 0.5;
          camera.position.z += e.deltaY * zoomSpeed;
          camera.position.z = Math.max(100, Math.min(1000, camera.position.z));
        };

        const onTouchStart = (e) => {
          e.preventDefault();
          if (e.touches.length === 1) {
            isDragging = true;
            prevMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
          } else if (e.touches.length === 2) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            initialPinchDistance = Math.hypot(dx, dy);
            initialCameraZ = camera.position.z;
          }
        };

        const onTouchMove = (e) => {
          e.preventDefault();
          if (e.touches.length === 1 && isDragging) {
            const deltaX = e.touches[0].clientX - prevMouse.x;
            const deltaY = e.touches[0].clientY - prevMouse.y;
            prevMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };

            if (groupRef.current) {
              groupRef.current.rotation.y += deltaX * 0.01;
              groupRef.current.rotation.x += deltaY * 0.01;
            }
          } else if (e.touches.length === 2 && initialPinchDistance !== null) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            const dist = Math.hypot(dx, dy);
            const scale = initialPinchDistance / dist;
            camera.position.z = Math.max(100, Math.min(1000, initialCameraZ * scale));
          }
        };

        const onTouchEnd = (e) => {
          if (e.touches.length < 2) initialPinchDistance = null;
          if (e.touches.length === 0) isDragging = false;
        };

        const canvas = renderer.domElement;
        canvas.addEventListener('mousedown', onMouseDown);
        window.addEventListener('mouseup', onMouseUp);
        window.addEventListener('mousemove', onMouseMove);
        canvas.addEventListener('wheel', onWheel, { passive: false });
        canvas.addEventListener('touchstart', onTouchStart, { passive: false });
        canvas.addEventListener('touchmove', onTouchMove, { passive: false });
        canvas.addEventListener('touchend', onTouchEnd);

        return () => {
          cancelAnimationFrame(reqId);
          canvas.removeEventListener('mousedown', onMouseDown);
          window.removeEventListener('mouseup', onMouseUp);
          window.removeEventListener('mousemove', onMouseMove);
          canvas.removeEventListener('wheel', onWheel);
          canvas.removeEventListener('touchstart', onTouchStart);
          canvas.removeEventListener('touchmove', onTouchMove);
          canvas.removeEventListener('touchend', onTouchEnd);
          if (mountRef.current) mountRef.current.removeChild(renderer.domElement);
        };
      }, [strokes, canvasSize, centerX]);

      return <div ref={mountRef} className="w-full h-full cursor-move touch-none" />;
    }

    // Render
    const root = ReactDOM.createRoot(document.getElementById("root"));
    root.render(<App />);
  </script>
</body>
</html>
